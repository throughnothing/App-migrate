#!/usr/bin/env perl
use App::Rad;
use Capture::Tiny qw( capture_stderr );
use DateTime;
use DBI;
use File::Slurp qw( read_file );
use List::MoreUtils qw( firstidx );
use List::Util qw( min max );

my $DB_TABLE='migrations';
my $CREATE_TABLE="
    CREATE TABLE $DB_TABLE (
        id SERIAL PRIMARY KEY,
        applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        version VARCHAR(20) NOT NULL
    )
";

# TODO: better way to suppress annoying msgs from postgres?
open STDERR, '>/dev/null';

App::Rad->run;

sub setup {
    my ($c) = @_;
    $c->register_commands({
            generate => 'Generate a new migration directory',
            install => 'Install migrations table',
            latest => 'Migrate to the latest timestamp',
            apply => 'Apply a specific version migration',
            unapply => 'Un-apply a specific version migration',
    });
}

sub pre_process {
    my ($c) = @_;

    # Default migrations dir
    $c->stash->{migration_dir} = $c->options->{dir} || 'migrations';

    unless (!$c->cmd || $c->cmd ~~ ['generate', 'help']){
        $c->getopt( 'dsn|d=s', 'user|u=s', 'pass|p=s', 'dir|r:s' )
            or $c->execute('usage') and return;

        $c->stash->{dbh} = DBI->connect(
            $c->options->{dsn},
            $c->options->{user},
            $c->options->{pass},
            {RaiseError => 1, AutoCommit => 0, PrintError => 0, PrintWarn => 1},
        );
    }
}

sub post_process {
    my ($c) = @_;
    $c->stash->{dbh}->disconnect if $c->stash->{dbh};
    print $c->output . "\n";
}

sub generate {
    my ($c) = @_;
    my $root = $c->stash->{migration_dir};

    my $now = DateTime->now->epoch;
    `mkdir -p $root/$now`;
    `touch $root/$now/up.sql`;
    `touch $root/$now/down.sql`;
    return "Created migration $root/$now";
}

sub install {
    my ($c) = @_;
    $c->stash->{dbh}->do( $CREATE_TABLE );
    $c->stash->{dbh}->commit;
    return "Created table $DB_TABLE.";
}

sub latest {
    my ($c) = @_;
    my @fs_versions = _fs_versions($c);
    my @db_versions = _db_versions($c);

    # Find versions in fs_versions but *not* in db_versions
    my %diff;
    @diff{ @fs_versions } = @fs_versions;
    delete @diff{ @$db_versions };
    my @diff = keys %diff;

    apply( $c, \@diff);
}

sub apply {
    my ($c, $versions) = @_;
    my $root = $c->stash->{migration_dir};
    $versions = $versions || $c->argv;
    my @fs_versions = _fs_versions($c);
    my @db_versions = _db_versions($c);

    return "Invalid versions" unless ref $versions eq 'ARRAY';
    # Sort the versions to apply
    $versions = [ sort( @$versions ) ];

    # Apply
    for my $v (@$versions){
        unless ( $v =~ /^\d+$/ ) {
            print "Invalid version number: $v, skipping.\n";
            next;
        }
        unless ( -e "$root/$v/up.sql" ) {
            print "Version $v does not exist, skipping.\n";
            next;
        }
        if( (firstidx { $_ == $v } @db_versions) >= 0 ) {
            print "Version $v is already applied, skipping.\n";
            next;
        }


        print "Applying $v...";
        my $up_sql = read_file("$root/$v/up.sql");
        _query_do( $c, $up_sql );
        _query_do( $c, "INSERT INTO $DB_TABLE (version) VALUES ('$v')" );
        print "done.\n";
    }

    $c->stash->{dbh}->commit;
    return '';
}

sub unapply {
    my ($c, $versions) = @_;
    my $root = $c->stash->{migration_dir};
    my @fs_versions = _fs_versions($c);
    my @db_versions = _db_versions($c);

    # Default to argv, then just the most recent
    $versions = $versions || [ $db_versions[0] ];

    return "Invalid versions" unless ref $versions eq 'ARRAY';
    # Sort the versions to apply
    $versions = [ reverse sort( @$versions ) ];

    # Apply
    for my $v (@$versions){
        unless ( $v =~ /^\d+$/ ) {
            print "Invalid version number: $v, skipping.\n";
            next;
        }
        unless ( -e "$root/$v/down.sql" ) {
            print "Version $v does not exist, skipping.\n";
            next;
        }
        if( (firstidx { $_ == $v } @db_versions) < 0 ) {
            print "Version $v not applied, skipping.\n";
            next;
        }
        next unless $v;


        print "Unapplying $v...";
        my $down_sql = read_file("$root/$v/down.sql");
        _query_do( $c, $down_sql );
        _query_do( $c, "DELETE FROM $DB_TABLE WHERE version ='$v'" );

        print "done.\n";
    }

    $c->stash->{dbh}->commit;
    return '';
}

sub _fs_versions {
    my ($c) = @_;
    my $root = $c->stash->{migration_dir};
    return split /\n/, `ls -1 $root 2> /dev/null`;
}

sub _db_versions {
    my ($c) = @_;
    my $rows = $c->stash->{dbh}->selectcol_arrayref(
        "SELECT version FROM $DB_TABLE ORDER BY id DESC");
    return @$rows;
}

sub _query_do {
    my ($c, $query) = @_;
    my $reval = $c->stash->{dbh}->do($query);
    die "Error running $query" unless $reval;
}
